// This is the grammar of describes all grammars accepted by the parser generator

// Since this grammar is parsed by a parser generated from itself, it effectively parses itself!

@ token
@ prune hard
COMMENT = regex("//[^\n]*") .

@ token
@ prune hard
WHITESPACE = regex("[ \n]*") .

@ token
TOKEN_NAME = regex("[A-Z_]+") .

@ token
INTEGER = regex("[0-9]+") .

@ token
PERIOD = regex("\\.") .

@ token
LITERAL_EXPRESSION = regex("\"([^\\\\]|\\\\(\"|n|\\\\))*?\"") .

// ---

ROOT = (LINE)* .

@ prune soft
LINE = TOKEN_DEFINITION | DECORATOR .

DECORATOR = "@" DECORATOR_VALUE .

DECORATOR_VALUE = "prune hard" | "prune soft" | "token" .

TOKEN_DEFINITION = TOKEN_NAME "=" TOKEN_COMPOUND_EXPRESSION PERIOD .

CONCATENATION_EXPRESSION = (TOKEN_EXPRESSION | CONJUNCTION_EXPRESSION | BRACKET_EXPRESSION) (TOKEN_COMPOUND_EXPRESSION)+ .

BRACKET_EXPRESSION = "(" TOKEN_COMPOUND_EXPRESSION BRACKET_EXPRESSION_END .

BRACKET_EXPRESSION_END = ")" | ")+" | ")*" | ")?" | BRACKET_EXPRESSION_REPEAT_RANGE .

BRACKET_EXPRESSION_REPEAT_RANGE = "){" INTEGER ",...}" .

@ prune soft
TOKEN_COMPOUND_EXPRESSION = TOKEN_EXPRESSION | CONCATENATION_EXPRESSION | CONJUNCTION_EXPRESSION | BRACKET_EXPRESSION .

CONJUNCTION_EXPRESSION = TOKEN_EXPRESSION "|" TOKEN_COMPOUND_EXPRESSION .

@ prune soft
TOKEN_EXPRESSION = LITERAL_EXPRESSION | TOKEN_NAME | REGEX_EXPRESSION .

REGEX_EXPRESSION = "regex(" LITERAL_EXPRESSION ")" .
