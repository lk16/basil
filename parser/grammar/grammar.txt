// This is the grammar of describes all grammars accepted by the parser generator

// Since this grammar is parsed by a parser generated from itself, it effectively parses itself!

@ token
@ prune hard
COMMENT = regex("//[^\n]*") .

@ token
@ prune hard
WHITESPACE = regex("[ \n]*") .

@ token
TOKEN_NAME = regex("[A-Z_]+") .

@ token
PERIOD = "." .

@ token
LITERAL_EXPRESSION = regex("\"([^\\\\]|\\\\.)*?\"") .

@ token
DECORATOR_MARKER = "@" .

@ token
DECORATOR_PRUNE_HARD = "prune hard" .

@ token
DECORATOR_PRUNE_SOFT = "prune soft" .

@ token
DECORATOR_TOKEN = "token" .

@ token
EQUALS = "=" .

@ token
BRACKET_OPEN = "(" .

@ token
BRACKET_AT_LEAST_ONCE = ")+" .

@ token
BRACKET_REPEAT = ")*" .

@ token
BRACKET_OPTIONAL = ")?" .

// This needs to be after other closing brackets, because it's shorter
@ token
BRACKET_CLOSE = ")" .

@ token
REGEX_START = "regex(" .

@ token
VERTICAL_BAR = "|" .

// ---

ROOT = (GRAMMAR_ENTRY)* .

GRAMMAR_ENTRY = (DECORATOR)* TOKEN_DEFINITION .

DECORATOR = DECORATOR_MARKER DECORATOR_VALUE .

DECORATOR_VALUE = DECORATOR_PRUNE_HARD | DECORATOR_PRUNE_SOFT | DECORATOR_TOKEN .

TOKEN_DEFINITION = TOKEN_NAME EQUALS TOKEN_COMPOUND_EXPRESSION PERIOD .

CONCATENATION_EXPRESSION = (TOKEN_EXPRESSION | CONJUNCTION_EXPRESSION | BRACKET_EXPRESSION) (TOKEN_COMPOUND_EXPRESSION)+ .

BRACKET_EXPRESSION = BRACKET_OPEN TOKEN_COMPOUND_EXPRESSION BRACKET_EXPRESSION_END .

BRACKET_EXPRESSION_END = BRACKET_CLOSE | BRACKET_AT_LEAST_ONCE | BRACKET_REPEAT | BRACKET_OPTIONAL .

@ prune soft
// the order of options matters here
TOKEN_COMPOUND_EXPRESSION = CONCATENATION_EXPRESSION | CONJUNCTION_EXPRESSION | BRACKET_EXPRESSION | TOKEN_EXPRESSION .

CONJUNCTION_EXPRESSION = TOKEN_EXPRESSION VERTICAL_BAR TOKEN_COMPOUND_EXPRESSION .

@ prune soft
TOKEN_EXPRESSION = TOKEN_NAME | REGEX_EXPRESSION | LITERAL_EXPRESSION .

REGEX_EXPRESSION = REGEX_START LITERAL_EXPRESSION BRACKET_CLOSE .
