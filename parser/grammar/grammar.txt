// This is the grammar of describes all grammars accepted by the parser generator

// Since this grammar is parsed by a parser generated from itself, it effectively parses itself!

@ token
@ prune hard
COMMENT = regex("//[^\n]*") .

@ token
@ prune hard
WHITESPACE = regex("[ \n]*") .

@ token
TOKEN_NAME = regex("[A-Z_]+") .

@ token
PERIOD = regex("\\.") .

@ token
LITERAL_EXPRESSION = regex("\"([^\\\\]|\\\\(\"|n|\\\\))*?\"") .

@ token
DECORATOR_MARKER = regex("@") .

@ token
DECORATOR_PRUNE_HARD = "regex("prune hard") .

@ token
DECORATOR_PRUNE_SOFT = "regex("prune soft") .

@ token
DECORATOR_TOKEN = "regex("token") .

@ token
EQUALS = regex("=") .

@ token
BRACKET_OPEN = regex("\\(") .

@ token
BRACKET_CLOSE = regex("\\)") .

@ token
BRACKET_AT_LEAST_ONCE = regex("\\)\\+") .

@ token
BRACKET_REPEAT = regex("\\)\\*") .

@ token
BRACKET_OPTIONAL = regex("\\)\\?") .

@ token
REGEX_START = regex("regex\\(")

@ token
VERTICAL_BAR = regex("\\|")

// ---

ROOT = (LINE)* .

@ prune soft
LINE = TOKEN_DEFINITION | DECORATOR .

DECORATOR = DECORATOR_MARKER DECORATOR_VALUE .

DECORATOR_VALUE = DECORATOR_PRUNE_HARD | DECORATOR_PRUNE_SOFT | DECORATOR_TOKEN .

TOKEN_DEFINITION = TOKEN_NAME EQUALS TOKEN_COMPOUND_EXPRESSION PERIOD .

CONCATENATION_EXPRESSION = (TOKEN_EXPRESSION | CONJUNCTION_EXPRESSION | BRACKET_EXPRESSION) (TOKEN_COMPOUND_EXPRESSION)+ .

BRACKET_EXPRESSION = BRACKET_OPEN TOKEN_COMPOUND_EXPRESSION BRACKET_EXPRESSION_END .

BRACKET_EXPRESSION_END = BRACKET_CLOSE | BRACKET_AT_LEAST_ONCE | BRACKET_REPEAT | BRACKET_OPTIONAL

@ prune soft
TOKEN_COMPOUND_EXPRESSION = TOKEN_EXPRESSION | CONCATENATION_EXPRESSION | CONJUNCTION_EXPRESSION | BRACKET_EXPRESSION .

CONJUNCTION_EXPRESSION = TOKEN_EXPRESSION VERTICAL_BAR TOKEN_COMPOUND_EXPRESSION .

@ prune soft
TOKEN_EXPRESSION = LITERAL_EXPRESSION | TOKEN_NAME | REGEX_EXPRESSION .

REGEX_EXPRESSION = REGEX_START LITERAL_EXPRESSION BRACKET_CLOSE .
