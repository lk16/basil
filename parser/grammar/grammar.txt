// This is the grammar of describes all grammars accepted by the parser generator

// Since this grammar is parsed by a parser generated from itself, it effectively parses itself!

ROOT = (LINE)*

@ prune soft
LINE = COMMENT_LINE | WHITESPACE_LINE | TOKEN_DEFINITION_LINE | DECORATOR_LINE

DECORATOR_LINE = "@" WHITESPACE DECORATOR_VALUE WHITESPACE "\n"

DECORATOR_VALUE = "prune hard" | "prune soft" | ("forbidden" WHITESPACE TOKEN_COMPOUND_EXPRESSION)

@ prune hard
COMMENT_LINE = regex("//[^\n]*\n")

@ prune hard
WHITESPACE_LINE = regex(" *\n")

TOKEN_DEFINITION_LINE = TOKEN_NAME WHITESPACE "=" WHITESPACE TOKEN_COMPOUND_EXPRESSION WHITESPACE "\n"

TOKEN_NAME = regex("[A-Z_]+")

CONCATENATION_EXPRESSION = TOKEN_EXPRESSION (WHITESPACE TOKEN_COMPOUND_EXPRESSION)+

BRACKET_EXPRESSION = "(" WHITESPACE TOKEN_COMPOUND_EXPRESSION WHITESPACE BRACKET_EXPRESSION_END

BRACKET_EXPRESSION_END = ")" | ")+" | ")*" | ")?" | BRACKET_EXPRESSION_REPEAT_RANGE

BRACKET_EXPRESSION_REPEAT_RANGE = "){" INTEGER ",...}"

INTEGER = regex("[0-9]+")

@ prune soft
TOKEN_COMPOUND_EXPRESSION = TOKEN_EXPRESSION | CONCATENATION_EXPRESSION | CONJUNCTION_EXPRESSION | (BRACKET_EXPRESSION (WHITESPACE TOKEN_COMPOUND_EXPRESSION)?)

CONJUNCTION_EXPRESSION = TOKEN_EXPRESSION WHITESPACE "|" WHITESPACE TOKEN_COMPOUND_EXPRESSION

@ prune soft
TOKEN_EXPRESSION = LITERAL_EXPRESSION | TOKEN_NAME | REGEX_EXPRESSION

REGEX_EXPRESSION = "regex(" LITERAL_EXPRESSION ")"

@ prune hard
WHITESPACE = regex(" *")

LITERAL_EXPRESSION = regex("\"([^\\\\]|\\\\(\"|n|\\\\))*?\"")
