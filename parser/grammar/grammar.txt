// This is the grammar of describes all grammars accepted by the parser generator

// Since this grammar is parsed by a parser generated from itself, it effectively parses itself!

@ terminal
@ pruned
WHITESPACE = regex("[ \n]*") .

@ terminal
@ pruned
COMMENT = regex("//[^\n]*") .

@ terminal
LITERAL_EXPRESSION = regex("\"([^\\\\]|\\\\(\"|n|\\\\))*?\"") .

@ terminal
INTEGER = regex("[0-9]+") .

@ terminal
DECORATOR_MARKER = "@" .

@ terminal
TOKEN_DEFINITION_END = "." .

@ terminal
TOKEN_NAME = regex("[A-Z_]+") .

@ terminal
DECORATOR_PRUNED = "pruned" .

@ terminal
DECORATOR_TOKEN = "terminal" .

@ terminal
EQUALS = "=" .

@ terminal
BRACKET_OPEN = "(" .

@ terminal
BRACKET_CLOSE = ")" .

@ terminal
BRACKET_CLOSE_AT_LEAST_ONCE = ")+" .

@ terminal
BRACKET_CLOSE_REPEAT = ")*" .

@ terminal
BRACKET_CLOSE_OPTIONAL = ")?" .

@ terminal
VERTICAL_BAR = "|" .

@ terminal
REGEX_START = "regex(" .

// ---

ROOT = (TOKEN_DEFINITION)* .

TOKEN_DEFINITION = (DECORATOR)* TOKEN_NAME EQUALS TOKEN_COMPOUND_EXPRESSION TOKEN_DEFINITION_END .

DECORATOR = DECORATOR_MARKER DECORATOR_VALUE .

DECORATOR_VALUE = DECORATOR_PRUNED | DECORATOR_TOKEN .

CONCATENATION_EXPRESSION = (TOKEN_EXPRESSION | CONJUNCTION_EXPRESSION | BRACKET_EXPRESSION) (TOKEN_COMPOUND_EXPRESSION)+ .

BRACKET_EXPRESSION = BRACKET_OPEN TOKEN_COMPOUND_EXPRESSION BRACKET_EXPRESSION_END .

BRACKET_EXPRESSION_END = BRACKET_CLOSE | BRACKET_CLOSE_REPEAT | BRACKET_CLOSE_AT_LEAST_ONCE | BRACKET_CLOSE_OPTIONAL .

TOKEN_COMPOUND_EXPRESSION = TOKEN_EXPRESSION | CONCATENATION_EXPRESSION | CONJUNCTION_EXPRESSION | BRACKET_EXPRESSION .

CONJUNCTION_EXPRESSION = TOKEN_COMPOUND_EXPRESSION VERTICAL_BAR TOKEN_COMPOUND_EXPRESSION .

TOKEN_EXPRESSION = LITERAL_EXPRESSION | TOKEN_NAME | REGEX_EXPRESSION .

REGEX_EXPRESSION = REGEX_START LITERAL_EXPRESSION BRACKET_CLOSE .
